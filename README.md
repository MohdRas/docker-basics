#  docker-basics
https://www.youtube.com/watch?v=3c-iBn73dDE

# how to navigate to directoty on the host and container to check the data stored so far ?

# Docker Engine vs WSL 2 vs Docker Desktop
- Docker Engine
  - background service (called a docker daemon "dockerd") that run instructions for containers, images, storage, and networking.
  - Docker Engine is Linux-kernel based. it can only run natively on Linux. It cannot run directly on the Windows kernel.
- WSL 2 (Windows Subsystem for Linux) - DOCKER HOST
  - Linux-kernel based VM.
  - It creates the necessary Linux environment that the Docker Engine needs to run.
  - "ping host.docker.internal" from inside of a container
      - print the IP address of the DOCKER HOST.
  - Connect to a web server running on your machine at port 8080
      - If you have a service (e.g., a database or API) running on your machine, your container application can connect to it like this:
      - curl http://host.docker.internal:8080
  - Docker Host" and your laptop's localhost are technically not the same thing, but Docker Desktop performs networking magic to make them appear the same in many common scenarios 
- Docker Desktop for Windows
  - A desktop application with GUI and CMD integration.
  - Installs & Manages WSL 2
  - Installs & Manages Docker Engine

# What is Container & docker
  - container has its own isolated environment ( application + dependencies + configuration)
    - With containers, no need to install any application directly on OS.
    - One commmand to fetch the image & start the container.
    - docker run postgres:9.6 -->> download + run an image->> postgres:9.6 => name of the image:version
      - find first image LOCALLY ( on the docker host (WSL VM) ) ->> if not found then download it from docker hub.
      - Different versions of the image can be downloaded and run on the same docker host (WSL VM) ( local machine )
      - each layer of the image is downloaded separately.
      - Downloading two versions of the same image
        - After downloading first version, if we download second version, then the layers which are present LOCALLY, won't be downloaded again. 
  - docker image vs docker container
    - docker image is the one which actually reside on repository ( docker hub )
    - docker image is the portable/movable arftifact.
    - docker image is pulled and started on my local machine (docker host (WSL VM))
      - it is now "a container running on my local machine".
      - it creates a container environment.
  - With Containers, development & operations team work together, to package an application in a container with all its dependencies & configuration.
  - Deployment before containers - 
    - Portable actifact(JAR/WAR + Database service + Instructions ). 
    - Development team give the Portable actifact to the Operations team. Operations team deploy the application.
    - Dependency versions conflicts.
    - Misunderstanding between development & operations team.
    - Textual guide for deployment about External Dependencies, instructions & configurations.
  - Development & deployment improvement
    - Development improvement 
      - No need to follow different instructions to install applications ( DB ) for each OS & Application.
    - Deployment imporovement 
      - No need to share steps to deploy it along with its artifact, dependencies and configuration.
  - Where to store these images? 
    - image repository is used to store images.
  - Private repository of images. 
    - Companies have their own private repository for their own images.
  - Public Repository ( DockerHub ) for Docker images 
    - Only docker images can reside.
    - Official & non-official container images ( Jenkins ) .
   
  - Layers of a image
    - base image ->> intermediate image ->> application image
    - base image layer (Linux based image - small in size ) - basic OS & dependencies
    - dependency layer - library + framework
    - code layer - code + configuration
    - build layer - tools & scripts to compile the application
    - run layer - runtime dependencies + configuration

  # Docker vs VM.
  - Both are virtualization tools.
  - What part of OS, Docker virtualize ?
    - Docker virtualize the Applications layer and uses the Kernel of the Host machine.
    - Size -->> Docker image smaller than VM
    - Speed ->> Docker containers start & run faster than VM
    - Compatibility -->> VM of any OS can run on any Host OS.
  - What part of OS, VM virtualize ?
    - VM virtualizes the applications layer and OS Kernel layer. 
    - it virtualizes the complete OS layer (OS Kernel + Applications).
  - OS architecture ( Hardware -> OS -> Software Applications (Excel) )
  - Layers of any OS
    - Applications layer 
      - run on OS Kernel Layer
    - OS Kernel layer 
      - communicate with Hardware ( CPU + MEMORY )
    - Hardware laqyer
      - CPU + MEMORY
    - Running Linux based image might not be compatible on windows host ( Windows Kernel + Windows Applications ) 
      - it is true for windows version < 10 and old mac versions.
      - This problem can be solved through WSL2 ( WINDOWS SUB SYSTEM FOR LINUX ). It is Linux-based Kernel inside VM of Windows.
      - This means Linux image is not directly running on windows kernel, rather on the Linux kernel inside windows VM.
      - Windows kernel can not run Linux based image natively
      - Docker ToolBox(Legacy Solution) is used to run any OS based image on any Host OS.
# Docker installation.
- Installation will differ for each OS and its version.
- Install docker on Windows/Mac/Linux
- Community Edition ( CE ) & Enterprise Edition ( EE ) 
- Prerequisites ( System Requirements )
  - OS version & Hardware criteria (RAM)
  - Installation includes - DOCKER ENGINE, DOCKER CLI, DOCKER COMPOSE, DOCKER MACHINE and KITEMATIC
  - Docker for Mac
    - If there are multiple account on a machine, then quit Docker on one account, to run it on another account. 
  - Docker for windows
    - windows version docker must be compatible.
    - virtualization must be enabled 
      - CPU under performance tab, virtualization enabled
    - Docker NATIVELY runs only on Windows 10 & above versions

# Docker commands.
- container and image
  - container is a running environment(STATE) on local machine for an image.
  - all the environment stuffs ( virtual file system, environment config ) are provided by the container. Only images comes from the registry. 
  - each container has a port.
  - file system is vitual in containers.
- starting docker desktop from CMD
    - copy past in CMD "C:\Program Files\Docker\Docker\Docker Desktop.exe" 
    - "docker info" command
        - info about docker engine
 
- "docker info" command
    - Docker Root Dir: /var/lib/docker
    - Server:
        - Images: 3
        - Containers: 33
            - Running: 31
            - Paused: 0
            - Stopped: 2
- "help" about a "command"
    - docker run --help
    - docker pull --help
    - docker network --help
    - docker container --help
    - docker image --help 
- Tag 
  - tag is basically the version of an image.
  - Example - lastest/ 9.6 
- docker pull IMAGE_NAME:TAG
  - docker pull redis:4.0
  - pull an image from docker hub.
      - "docker images" command will show this image.
  - docker pull docker.io/library/redis:4.0 = [REGISTRY]/[NAMESPACE]/[IMAGE]:[TAG]
      - In private repository (AWS ECR), we cannot skip [REGISTRY]/[NAMESPACE].
      - REGISTRY = "docker.io" for "docker hub"
      - NAMESPACE
          - "library" for "official docker" images.
          - for custom images
              - bitnami/mongodb or jfrog/artifactory-pro
                  - the part before the slash (bitnami or jfrog) is the user/organization namespace

- docker run IMAGE_NAME:TAG
  - docker run redis:4.0
      - pull an image & start the container. 
      - "pull an image" is optional. It will pull if it is not present LOCALLY.
      - 
  - "docker run -d --name mongo-db -p 27027:27017 --network mongo-network -e MONGO_INITDB_ROOT_USERNAME=admin -e  MONGO_INITDB_ROOT_PASSWORD=password mongodb/mongodb-community-server"
      - "p 27017:27017"
          - exposing container to the docker host (WSL VM).
          - services running inside this container will be accessible to the external world using "docker host (WSL VM) IP" and "docker host (WSL VM) PORT".
          - docker host (WSL VM) IP:docker host (WSL VM) PORT will be accesible in browser.
          - docker port CONTAINER_ID/NAME
            - display the port binding of a container. 
      - "-d"
          - to run container in the "BACKGROUND"
          - manually attaching to the DOCKER CONSOLE
            - docker attach CONTAINER_ID/NAME
      - "-e"
          - environment variables
          - MANGO_INITDB_ROOT_USERNAME=admin
          - MANGO_INITDB_ROOT_PASSWORD=password
      - "--name mangodb"
          - define a name to the container.
       - "--net mango-network"
          - attaching a network to this container.

- docker images 
  - list images LOCALLY.
- docker ps 
  - RUNNING containers. 
  - ps stands for PROCESS STATUS.
- docker ps -a 
  - RUNNING / NOT-RUNNING containers. 
  - NOT-RUNNING containers can be started again.
- docker logs CONTAINER_ID/NAME -f
  - print the logs of a RUNNING container.
  - "-f" for streaming the logs.
- docker inspect CONTAINER_ID/NAME
  - All details about the container
  - "Mounts" key will show details about the volume type.
  - SOURCE & DESTINATION of the volume.
- docker inspect VOLUME_NAME
  - All details about the volume.
- docker start CONTAINER_ID/NAME 
  - start a STOPPED container.
- docker stop CONTAINER_ID/NAME 
  - stop the RUNNING container.
- docker exec -it CONTAINER_ID/NAME /bin/bash
   - docker exec -it CONTAINER_ID/NAME /bin/sh 
   - run a linux command from inside a container.
   - All Linux command won't be available as it is light weight linux image.
   - open "bash" or "sh" shell inside the container
      - exit -> to come out of the terminal.
      - env -> print all the environment variables.
      - ls -> list all the child folder.
      - pwd -> print out the directory.
      - cd / -> go to homme directory.
      - ls -> what is inside the home directory.
- container port vs docker host (WSL VM) port
  - multiple containers can run on a single docker host (WSL VM) machine.
  - each container will have a port.
  - Multiple container can have the same port.
  - docker host (WSL VM)_PORT to CONTAINER_PORT binding must be UNIQUE on a SINGLE host machine.
  - Container will listen to the request only if docker host (WSL VM)_PORT to CONTAINER_PORT binding is present.
  - This binding is done while running an image.
  - docker run -p docker host (WSL VM)_PORT:CONTAINER_PORT redis
    - docker run -p 6000:6379 redis 
    - Binding docker host (WSL VM)_PORT 6000 to CONTAINER_PORT 6379.
  - docker run -p 6000:6379 --name CONTAINER_NAME redis:4.0
    - docker run -p 6000:6379 --name old-redis redis:4.0   
    - "old-redis" is the CONTAINER_NAME
- docker run vs docker start command
  - docker run -> optionally download the image if it is not present LOCALLY.
  - both commands start the container. 
  - docker run -> start a NEW container.
  - docker start -> start a STOPPED container.
  - Docker run -> can have multiple options ( -d -p --name ) while starting running itself.
  - docker start -> will start the container with all the options which were already given in docker run command. New options cannot be given.
# Debug a container.
- docker run -d -p 60001:6379 --name redis-older redis:4.0
  - creating a container with name "redis-older"
- docker run -d -p 60001:6379 --name redis-latest redis
  - creating a container with name 'redis-latest'
- docker logs CONTAINER_ID/NAME -> Logs of a container
- docker logs CONTAINER_NAME -> Logs of a container
- docker exec -it CONTAINER_ID/NAME /bin/bash
  - inside the container as a root user.
  - virtual file system inside the container.
  - these containers are light weight linux images hence all the linux command won't be available like "curl" command.
  - ls -> list all the child folder.
  - pwd -> print out the directory.
  - cd / -> go to homme directory.
  - ls -> what is inside the home directory.
  - env -> print all the environment variables.
  - exit -> out of the terminal.

# Developing with containers.
- JS(UI) + Node JS (backend) application with "MangoDB" as database and "Mango-express" as SQL client.
- MangoDB and Mango-express are downloaded and run from the docker repository.
    - docker pull mango -> pulling lastest version of MangoDB image.
    - docker pull mango-express -> pulling lastest version of Mango-express image.
- mango-express will connect to the MangoDB through docker network concept.
  - Docker Network (Connection between mango and mango-expres)
    - docker creates isolated docker-network where containers are running in.
    - two containers in the same docker network can talk to each other with just the container name.
    - "docker network ls" command
        - docker networks by defaults.
    - "docker network create mongo-network" command 
        - creates our own custom network "mango-network"
    - run mangodb in "mango-network".
        - "docker run -d --name mongodb --network mongo-network -p 27017:27017 -e MONGO_INITDB_ROOT_USERNAME=admin -e MONGO_INITDB_ROOT_PASSWORD=password mongo"
        - 27017:27017 is the PORT_BINDING.
        - admin is the USER_NAME.
        - password is the PASSWORD.
        - mango is the IMAGE_NAME.
        - mango-network is the DOCKER_NETWORK.
        - mangodb is the CONTAINER_NAME. It will be used by mango-express to connect to it.
    - check if mangodb started or not
        - docker logs CONTAINER_ID/NAME
    - connecting mango-express to mango container
        - "docker run -d --name mongo-express --network mongo-network -p 8081:8081 -e ME_CONFIG_MONGODB_ADMINUSERNAME=admin -e ME_CONFIG_MONGODB_ADMINPASSWORD=password -e ME_CONFIG_MONGODB_SERVER=mongodb mongo-express"
        - 8081:8081 is the PORT_BINDING.
        - admin is the USER_NAME.
        - password is the PASSWORD.
        - mango is the CONTAINER_NAME to connect with
        - mango-expressdb is the CONTAINER_NAME, which we are creating now.
        - mango-express is the IMAGE_NAME.
        - mango-network is the DOCKER_NETWORK.
        
- our application will connect to "mangodb" database using the localhost:27017
    - db URL in the codebase
        - "mangodb://admin:password@localhost:27017"
        - mangodb is the PROTOCAL.
        - admin is the USER_NAME while running mangodb container.
        - password is the PASSWORD while running mangodb container.

- browser(which is on the host, outside the docker network) will connect to our js application using docker host (WSL VM):port number (localhost:8080)
- our node js application will connect with the "mangodb" database.
- Once this application is built, we will push the codebase to GIT. Jenkins will build and create an image out of this.
- This image can be pushed back to docker repository. 
- This image and MangoDB need to be FECTHED from the docker repository and deployed on a DEPLOYMENT SERVER. 


# Docker compose
  - Running multiple containers ( services ) .
  - if we restart the mangodb containers, everything which was saved earlier, will be lost after restart.
  - there is no data persistence in the container itself. Data Volumes resolve this problem.
  - create docker network
      - docker network create mango-network
  - start mangodb
      - docker run -p 27017:27017 -d -e MANGO_INITDB_ROOT_USERNAME=admin -e MANGO_INITDB_ROOT_PASSWORD=password --name mangodb --net mango-network mango
  - start mango-express
      - docker run -p 8081:8081 -d --name mango-expressdb --net mango-network -e ME_CONFIG_MANGODB_ADMINUSERNAME=admin -e ME_CONFIG_MANGODB_ADMINPASSWORD=password -e ME_CONFIG_MANGODB_SERVER=mangodb  mango-express
  - All above 3 can be done using docker-compose file and commmand.
      - docker-compose -f FILE_NAME.yaml up.
          - FILE_NAME is docker-compose-file.
          - create DOCKER_NETWORK and starts the CONTAINERS.
      - docker-compose -f FILE_NAME.yaml down.
          - FILE_NAME is docker-compose-file.
          - stop & remove DOCKER_NETWORK and CONTAINERS.
      - docker-compose-file.yaml
        - version : '3'
        - mangodb:
            - image : mango
            - ports :
                - 27017:27017
            - environments :
                - MANGO_INITDB_ROOT_USERNAME : admin
                - MANGO_INITDB_ROOT_PASSWORD : password
        - mango-express:
            - image : mango-express
            - ports :
                - 8081:8081
            - environments :
                - ME_CONFIG_MANGODB_ADMINUSERNAME : admin
                - ME_CONFIG_MANGODB_ADMINPASSWORD : password
                - ME_CONFIG_MANGODB_SERVER : mangodb
# Dockerfile.txt
- blueprint for creating docker images.
- our application ----> Dockerfile -----> docker image.
- our application developed -----> git commit --------> CI (Jenkins) -------> build application , create docker image and push it to docker repository.
- copy artifacts ( war, jar, bundle.js ) to Dockerfile.
- Dockerfile
    - FROM node:13-alpine
        - base image for the image to be created. 
        - when we create container from our image then node commands will be available inside the container by defaults.
    - ENV MANGO_DB_USERNAME=admin /
        - MANGO_DB_PWD=password
        - Optional Environment variables.
        - Environment variables can be defined in docker-compose file too.
    - RUN mkdir -p /home/app
        - run any linux command. 
        - It runs inside a container.
        - create VIRTUAL FOLDER /home/app
        - MULTIPLE RUN commands allowed.
    - COPY . /home/app
        - It runs on HOST machine.
        - copy CURRENT FOLDER . to VIRTUAL FOLDER /home/app
        - CURRENT FOLDER is the folder containing the Dockerfile.txt.
    - CMD ["node", "/home/app/server.js']
        - ONLY ONE entrypoint comment.   
        - start the app with "node server.js". 
        - Node is preinstalled because of the base image. Entry point command.
- docker build -t IMAGE_NAME:TAG CURRENT_FOLDER
    - docker build -t myapp:1.0 .
    - Dockerfile.txt is in the CURRENT_FOLDER (.)
    - building an image from CURRENT_FOLDER(.)
- running our own IMAGE
    - docker run myapp:1.0
- When we update the Dockerfile.txt then we need to build the image again.
    - docker rm CONTAINER_ID/NAME
        - CONTAINER_ID/NAME can be found with command "docker ps -a | grep myapp"
        - remove the container
    - docker rmi IMAGE_ID
       - IMAGE_ID can be found with "docker images"
       - remove an image AFTER removing container.
- docker build -t IMAGE_NAME:TAG CURRENT_FOLDER
    - docker build -t myapp:1.0 .
    - buiding image again.
- try docker exec -it CONTAINER_ID/NAME /bin/sh
    - ls
    - env
    - ls /home/app 
    - if "/bin/bash" does not work
    - "exit" to leave the terminal.
# Private Repository ( Registry ) for docker images on AWS - Elastic Container Registry ( ECR )
- create private repository on ECR with AWS credentials.
    - repository_domain/REPOSITORY_NAME
    - REPOSITORY_NAME(my-app) is same as IMAGE_NAME(my-app).
    - In ECR, ONE repository per image.
    - PUSHING different VERSIONS/TAGS of the same image.
- PUSHING docker image to AWS
    - login to AWS
        - Login is MANDATORY for private repository.
        - "view push commands" on repository will show commands to LOGIN into AWS.
        - past the same command in CMD.
    - TAG/RENAME docker image to include repository_domain
        - docker tag my-app:1.0 repository_domain/my-app:1.0
        - docker tag IMAGE_NAME:TAG repository_domain/IMAGE_NAME:TAG 
        - "docker images" will show 2 images with TAG 1.0
    - push TAGGED image
        - docker push repository_domain/my-app:1.0
        - docker push repository_domain/IMAGE_NAME:TAG
- change codebase and change the Dockerfile.txt
    - rename "/home/app" to "/home/node-app"
    - docker build -t my-app:1.1 .
    - docker images 
    - docker tag my-app:1.1 repository_domain/my-app:1.1
    - docker images
    - docker push repository_domain/my-app:1.1
        - The layers which are already pushed as part of image my-app:1.0, won't be pushed again.
    - Now, 2 images in ECR with tag "1.0" and "1.1"

# Deploying containerized application.
- "my-app" image pulled from the private repository (ECR). Login is needed.
- "mangodb" and "mango-express" image pulled from dockerhub.
- docker-compose to deploy "my-app" to "dev" environment.
- "dev" environment must need to LOGIN to ECR.
- docker-compose -f docker-compose-file.yaml up                                                                                                                                       
- docker-compose-file.yaml
- version : '3'
        - my-app :
            - image : repository_domain/my-app:1.0
            - ports : 
                - 3000:3000
        - mangodb :
            - image : mango
            - ports :
                - 27017:27017
            - environments :
                - MANGO_INITDB_ROOT_USERNAME : admin
                - MANGO_INITDB_ROOT_PASSWORD : password
        - mango-express :
            - image : mango-express
            - ports :
                - 8081:8081
            - environments :
                - ME_CONFIG_MANGODB_ADMINUSERNAME : admin
                - ME_CONFIG_MANGODB_ADMINPASSWORD : password
                - ME_CONFIG_MANGODB_SERVER : mangodb
# Volumes
  - data persistence for databases and other statefull applications.
  - The data of a container is stored in its virtual file system. It is not-persist.
  - when we start a container, a FRESH virtual file system is created. Hence data lost.
  - use "docker volume" or "bind mounts".
  - we mount host file system to virtual file system.
      - -v docker_volume_name:directory in virtual_file_system
      - -v mango_data:/data/db
          - mango_data is the docker volume created automatically. It can be seen using docker volumes ls.
          - /data/db is the directory inside the container which store data of a container.
          - docker exec -it 12a053d917c1 /bin/bash
          - inside shell of the container.
          - cd /data/db
          - ls -l
      - -v c_drive_path:/data/db
          -  c_drive_path = "C:\Users\mohd.rasid\file_name", if WSL is not used.
          -  c_drive_path = "/mnt/C:/Users/mohd.rasid/file_name", if wsl used.
# Volumes Demo


